---
# Default values for opentelemetry-collector.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Refer to https://github.com/open-telemetry/opentelemetry-helm-charts/tree/main/charts/opentelemetry-collector for the list of available configurable parameters
# Release - (0.91.0) https://github.com/open-telemetry/opentelemetry-helm-charts/blob/opentelemetry-collector-0.91.0/charts/opentelemetry-collector/values.yaml

nameOverride: ""
fullnameOverride: "opentelemetry-collector"

# Valid values are "daemonset", "deployment", and "statefulset".
mode: "daemonset"

# Specify which namespace should be used to deploy the resources into
namespaceOverride: "opentelemetry"

# Handles basic configuration of components that
# also require k8s modifications to work correctly.
# .Values.config can be used to modify/add to a preset
# component configuration, but CANNOT be used to remove
# preset configuration. If you require removal of any
# sections of a preset configuration, you cannot use
# the preset. Instead, configure the component manually in
# .Values.config and use the other fields supplied in the
# values.yaml to configure k8s as necessary.
presets:
  # Configures the collector to collect logs.
  # Adds the filelog receiver to the logs pipeline
  # and adds the necessary volumes and volume mounts.
  # Best used with mode = daemonset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#filelog-receiver for details on the receiver.
  logsCollection:
    enabled: true
    includeCollectorLogs: false
    # Enabling this writes checkpoints in /var/lib/otelcol/ host directory.
    # Note this changes collector's user to root, so that it can write to host directory.
    storeCheckpoints: false
    # The maximum bytes size of the recombined field.
    # Once the size exceeds the limit, all received entries of the source will be combined and flushed.
    maxRecombineLogSize: 102400
  # Configures the collector to collect host metrics.
  # Adds the hostmetrics receiver to the metrics pipeline
  # and adds the necessary volumes and volume mounts.
  # Best used with mode = daemonset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#host-metrics-receiver for details on the receiver.
  hostMetrics:
    enabled: false
  # Configures the Kubernetes Processor to add Kubernetes metadata.
  # Adds the k8sattributes processor to all the pipelines
  # and adds the necessary rules to ClusteRole.
  # Best used with mode = daemonset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#kubernetes-attributes-processor for details on the receiver.
  kubernetesAttributes:
    enabled: true
    # When enabled the processor will extra all labels for an associated pod and add them as resource attributes.
    # The label's exact name will be the key.
    extractAllPodLabels: false
    # When enabled the processor will extra all annotations for an associated pod and add them as resource attributes.
    # The annotation's exact name will be the key.
    extractAllPodAnnotations: false
  # Configures the collector to collect node, pod, and container metrics from the API server on a kubelet..
  # Adds the kubeletstats receiver to the metrics pipeline
  # and adds the necessary rules to ClusteRole.
  # Best used with mode = daemonset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#kubeletstats-receiver for details on the receiver.
  kubeletMetrics:
    enabled: false
  # Configures the collector to collect kubernetes events.
  # Adds the k8sobject receiver to the logs pipeline
  # and collects kubernetes events by default.
  # Best used with mode = deployment or statefulset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#kubernetes-objects-receiver for details on the receiver.
  kubernetesEvents:
    enabled: false
  # Configures the Kubernetes Cluster Receiver to collect cluster-level metrics.
  # Adds the k8s_cluster receiver to the metrics pipeline
  # and adds the necessary rules to ClusteRole.
  # Best used with mode = deployment or statefulset.
  # See https://opentelemetry.io/docs/kubernetes/collector/components/#kubernetes-cluster-receiver for details on the receiver.
  clusterMetrics:
    enabled: false

configMap:
  # Specifies whether a configMap should be created (true by default)
  create: true

# Base collector configuration.
# Supports templating. To escape existing instances of {{ }}, use {{` <original content> `}}.
# For example, {{ REDACTED_EMAIL }} becomes {{` {{ REDACTED_EMAIL }} `}}.
config:
  exporters:
    # https://github.com/open-telemetry/opentelemetry-collector/blob/main/exporter/debugexporter/README.md
    debug: # Exporter for sending "LOGGING" data to the console (stderr) via zap.Logger.
      verbosity: normal
      sampling_initial: 2  # default = 2
      sampling_thereafter: 1  # default = 1 (1 means that sampling is disabled)

    # https://github.com/open-telemetry/opentelemetry-collector/blob/main/exporter/otlpexporter/README.md
    otlp:  # Exporter for sending "TRACING, METRICS, LOGGING" data to the "Internal OpenTelemetry Gateway" endpoint using gRPC/OTLP - insecure.
      endpoint: opentelemetry-gateway.opentelemetry.svc.cluster.local:4317
      tls:
        insecure: false
        ca_file: /etc/gateway-ca/tls.crt

  extensions:
    # The health_check extension is mandatory for this chart.
    # Without the health_check extension the collector will fail the readiness and liveliness probes.
    # The health_check extension can be modified, but should never be removed.
    health_check:
      endpoint: ${env:MY_POD_IP}:13133
    memory_ballast: {}

  processors:
    # https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor/batchprocessor
    batch:
      send_batch_size: 4096  # default = 8192
      send_batch_max_size: 4096  # must be greater than or equal to `send_batch_size`. `0` means no upper limit of the batch size.
      timeout: 200ms  # default

    # If set to null, will be overridden with values based on k8s resource limits
    # https://github.com/open-telemetry/opentelemetry-collector/blob/main/processor/memorylimiterprocessor/README.md
    memory_limiter:
      check_interval: 1s
      limit_mib: 6000
      spike_limit_mib: 1600

    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/resourceprocessor/README.md
    # Ensures that we have logs labelled correctly with the right labels when the loggging is being processed in Loki.
    resource/linode-loki:
      attributes:
      - action: upsert
        key: loki.resource.labels
        value: environment, component, datacenter, path, k8s.container.name, k8s.pod.name, k8s.namespace.name

    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/resourcedetectionprocessor/README.md
    # Queries ""k8snode" name and adds to hostmetrics - otherwise hostmetrics does aggregates metrics and does not provide per node stats. Requires "node" clusterRole.
    resourcedetection/k8snode:
      detectors: [k8snode]

  receivers:
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.91.0/receiver/prometheusreceiver/README.md
    # https://prometheus.io/docs/prometheus/latest/configuration/configuration/
    prometheus:
      config:
        scrape_configs:
          # OpenTelemetry Collector Internal telemetry
          # https://opentelemetry.io/docs/collector/internal-telemetry/
          # https://github.com/open-telemetry/opentelemetry-collector/blob/v0.91.0/docs/observability.md
          # https://docs.datadoghq.com/opentelemetry/collector_exporter/collector_health_metrics/
          - job_name: "opentelemetry-collector"
            scrape_interval: "60s"
            scrape_timeout: "10s"
            static_configs:
              - targets:
                  # Using MY_POD_IP here means the instance/service_instance_id
                  # labels are set correctly; instead of multiple pods all
                  # having instance="localhost:8888".
                  - "${env:MY_POD_IP}:8888"
            # otelcol exports metrics with service_name and service_instance_id.
            # The prometheus receiver also wants to set this labels and will
            # merge the values. We drop these labels so that only the prometheus
            # receiver's labels are used.
            # https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/14900#issuecomment-1664090336
            metric_relabel_configs:
              - action: "labeldrop"
                regex: "service_instance_id|service_name"

    # Receiving LOGGING data and send to the "Internal OpenTelemetry Gateway" endpoint using gRPC/OTLP - insecure.
    filelog:
      include:
        - /var/log/pods/*/*/*.log
      include_file_path: true
      operators:
      - from: attributes["log.file.path"]
        to: resource["path"]
        type: move
      resource: 
        - environment: 'development'
        - component: 'objectstorage_gen2'
        - datacenter: 'unknown'
      retry_on_failure:
        enabled: true
  
    # Receiving "METRICS, TRACING, LOGGING" data through gRPC/otlp from microservices in the cluster (obj-endpoint + envoy).
    # https://github.com/open-telemetry/opentelemetry-collector/blob/main/receiver/otlpreceiver/README.md
    otlp:
      protocols:
        grpc:
          endpoint: ${env:MY_POD_IP}:4317

    # Receiver for collecting "METRICS" data from the "Kubernetes" service and send to the "Internal OpenTelemetry Gateway" endpoint using gRPC/OTLP - insecure.
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/kubeletstatsreceiver
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/kubeletstatsreceiver/documentation.md
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/kubeletstatsreceiver/documentation.md#optional-metrics
    # kubeletstats:
    #   collection_interval: 60s
    #   auth_type: "serviceAccount"
    #   endpoint: "${env:KUBERNETES_NODE_IP}:10250"
    #   insecure_skip_verify: true
    #   extra_metadata_labels:
    #     - container.id
    #     - k8s.volume.type
    #   k8s_api_config:
    #     auth_type: serviceAccount
    #   metric_groups:
    #     - node
    #     - pod
    #     - container
    #     - volume

    # https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/hostmetricsreceiver
    # https://opentelemetry.io/docs/kubernetes/collector/components/#host-metrics-receiver
    # hostmetrics:
    #   collection_interval: 30s
    #   root_path: /hostfs
    #   scrapers:
    #     cpu:
    #     disk:
    #     load:
    #     filesystem:
    #     memory:
    #     network:
    #     paging:
    #     processes:

    # Receiver for collecting "METRICS" data from the "Ratelimiter" service and send to the "Internal OpenTelemetry Gateway" endpoint using gRPC/OTLP - insecure.
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/statsdreceiver/README.md
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/statsdreceiver/testdata/config.yaml
    # statsd:
    #   endpoint: "0.0.0.0:9102"
    #   aggregation_interval: 60s
    #   enable_metric_type: true

    # Receiver for collecting "METRICS" data from the "Redis" service and send to the "Internal OpenTelemetry Gateway" endpoint using gRPC/OTLP - insecure.
    # https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/redisreceiver/README.md
    # redis:
    #   endpoint: "redis-cluster-headless.obj-endpoint.svc.cluster.local:6379"
    #   collection_interval: 60s
    #   password: ${env:REDIS_PASSWORD}
    #   tls:
    #     insecure: true

  service:
    telemetry:
      # OpenTelemetry Collector "Internal telemetry" - Metrics.
      metrics:
        level: "normal"
        address: "0.0.0.0:8888"
        # OpenTelemetry Collector "Internal telemetry" - Logging.
        # logs:
        #   level: 'debug'
    extensions:
      - health_check
      - memory_ballast
    pipelines:
      logs:
        exporters:
          - debug
          - otlp
        processors:
          - memory_limiter
          - resource/linode-loki
          - batch
        receivers:
          - otlp
          - filelog
      metrics:
        exporters:
          - debug
          - otlp
        processors:
          - memory_limiter
          # - resourcedetection/k8snode
          - batch
        receivers:
          - otlp
          # - prometheus
          # - kubeletstats
          # - hostmetrics
          # - statsd
          # - redis
      traces:
        exporters:
          - debug
          - otlp
        processors:
          - memory_limiter
          - batch
        receivers:
          - otlp

image:
  # If you want to use the core image `otel/opentelemetry-collector`, you also need to change `command.name` value to `otelcol`.
  repository: otel/opentelemetry-collector-contrib
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
  # When digest is set to a non-empty value, images will be pulled by digest (regardless of tag value).
  digest: ""
imagePullSecrets: []

# OpenTelemetry Collector executable
command:
  name: otelcol-contrib
  extraArgs: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

clusterRole:
  # Specifies whether a clusterRole should be created
  # Some presets also trigger the creation of a cluster role and cluster role binding.
  # If using one of those presets, this field is no-op.
  create: false
  # Annotations to add to the clusterRole
  # Can be used in combination with presets that create a cluster role.
  annotations: {}
  # The name of the clusterRole to use.
  # If not set a name is generated using the fullname template
  # Can be used in combination with presets that create a cluster role.
  name: ""
  # A set of rules as documented here : https://kubernetes.io/docs/reference/access-authn-authz/rbac/
  # Can be used in combination with presets that create a cluster role to add additional rules.

  # rules: []
  # https://opentelemetry.io/docs/kubernetes/collector/components/#kubeletstats-receiver
  rules:
    - apiGroups:
        - ""
      resources:
        - "services"
        - "endpoints"
        - "nodes"
        - "nodes/proxy"
        - "persistentvolumes"
        - "persistentvolumeclaims"
      verbs:
        - "get"
        - "list"
        - "watch"

  clusterRoleBinding:
    # Annotations to add to the clusterRoleBinding
    # Can be used in combination with presets that create a cluster role binding.
    annotations: {}
    # The name of the clusterRoleBinding to use.
    # If not set a name is generated using the fullname template
    # Can be used in combination with presets that create a cluster role binding.
    name: ""

podSecurityContext: {}
securityContext: {}

nodeSelector: {}

tolerations:
  - key: "tikv-ns"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  # Since `tikv-bucket` and `tikv-quota` share the same node pool,
  # there is no need to define an extra toleration
  - key: "tikv-bucket"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  - key: "tikv-policy"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  - key: "tikv-user"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  - key: "load-test"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

affinity: {}
topologySpreadConstraints: []

# Allows for pod scheduler prioritisation
priorityClassName: ""

#extraEnvs: []
# https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/22843#issuecomment-1758735732
extraEnvs:
  - name: KUBERNETES_NODE_IP
    valueFrom:
      fieldRef:
        fieldPath: status.hostIP
# k8snode resource detector env variable
# - name: K8S_NODE_NAME
#   valueFrom:
#     fieldRef:
#       fieldPath: spec.nodeName

extraEnvsFrom: []
extraVolumes:
  - name: gateway-ca
    secret:
      secretName: opentelemetry-gateway-server-secret

extraVolumeMounts:
  - mountPath: /etc/gateway-ca
    name: gateway-ca
    readOnly: true

# Configuration for ports
# nodePort is also allowed
ports:
  otlp:
    enabled: true
    containerPort: 4317
    servicePort: 4317
    hostPort: 4319  # KPP otelcol port clash - https://linode.slack.com/archives/C052CENRQHL/p1717487684505129
    protocol: TCP
    # nodePort: 30317
    appProtocol: grpc
  otlp-http:
    enabled: false
    containerPort: 4318
    servicePort: 4318
    hostPort: 4318
    protocol: TCP
  jaeger-compact:
    enabled: false
    containerPort: 6831
    servicePort: 6831
    hostPort: 6831
    protocol: UDP
  jaeger-thrift:
    enabled: false
    containerPort: 14268
    servicePort: 14268
    hostPort: 14268
    protocol: TCP
  jaeger-grpc:
    enabled: false
    containerPort: 14250
    servicePort: 14250
    hostPort: 14250
    protocol: TCP
  zipkin:
    enabled: false
    containerPort: 9411
    servicePort: 9411
    hostPort: 9411
    protocol: TCP
  metrics:
    # The metrics port is disabled by default. However you need to enable the port
    # in order to use the ServiceMonitor (serviceMonitor.enabled) or PodMonitor (podMonitor.enabled).
    enabled: true
    containerPort: 9090
    servicePort: 9090
    protocol: TCP

# Resource limits & requests. Update according to your own use case as these values might be too low for a typical deployment.
resources:
  requests:
    cpu: 500m
    memory: 500Mi
  limits:
    cpu: 2
    memory: 8Gi

podAnnotations:
  sidecar.istio.io/proxyCPU: "500m"
  # sidecar.istio.io/proxyCPULimit: "16000m"
  # sidecar.istio.io/proxyMemoryLimit: "8000Mi"
  proxy.istio.io/config: |
    concurrency: 16

podLabels: {}

# Common labels to add to all otel-collector resources. Evaluated as a template.
additionalLabels: {}
#  app.kubernetes.io/part-of: my-app

# Host networking requested for this pod. Use the host's network namespace.
hostNetwork: false

# Adding entries to Pod /etc/hosts with HostAliases
# https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
hostAliases: []
# - ip: "1.2.3.4"
#   hostnames:
#     - "my.host.com"

# Pod DNS policy ClusterFirst, ClusterFirstWithHostNet, None, Default, None
dnsPolicy: ""

# Custom DNS config. Required when DNS policy is None.
dnsConfig: {}

# only used with deployment mode
replicaCount: 1

# only used with deployment mode
revisionHistoryLimit: 10

annotations: {}

# List of extra sidecars to add
extraContainers: []
# extraContainers:
#   - name: test
#     command:
#       - cp
#     args:
#       - /bin/sleep
#       - /test/sleep
#     image: busybox:latest
#     volumeMounts:
#       - name: test
#         mountPath: /test

# List of init container specs, e.g. for copying a binary to be executed as a lifecycle hook.
# Another usage of init containers is e.g. initializing filesystem permissions to the OTLP Collector user `10001` in case you are using persistence and the volume is producing a permission denied error for the OTLP Collector container.
initContainers: []
# initContainers:
#   - name: test
#     image: busybox:latest
#     command:
#       - cp
#     args:
#       - /bin/sleep
#       - /test/sleep
#     volumeMounts:
#       - name: test
#         mountPath: /test
#  - name: init-fs
#    image: busybox:latest
#    command:
#      - sh
#      - '-c'
#      - 'chown -R 10001: /var/lib/storage/otc' # use the path given as per `extensions.file_storage.directory` & `extraVolumeMounts[x].mountPath`
#    volumeMounts:
#      - name: opentelemetry-collector-data # use the name of the volume used for persistence
#        mountPath: /var/lib/storage/otc # use the path given as per `extensions.file_storage.directory` & `extraVolumeMounts[x].mountPath`

# Pod lifecycle policies.
lifecycleHooks: {}
# lifecycleHooks:
#   preStop:
#     exec:
#       command:
#       - /test/sleep
#       - "5"

# liveness probe configuration
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
##
livenessProbe:
  # Number of seconds after the container has started before startup, liveness or readiness probes are initiated.
  # initialDelaySeconds: 1
  # How often in seconds to perform the probe.
  # periodSeconds: 10
  # Number of seconds after which the probe times out.
  # timeoutSeconds: 1
  # Minimum consecutive failures for the probe to be considered failed after having succeeded.
  # failureThreshold: 1
  # Duration in seconds the pod needs to terminate gracefully upon probe failure.
  # terminationGracePeriodSeconds: 10
  httpGet:
    port: 13133
    path: /

# readiness probe configuration
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
##
readinessProbe:
  # Number of seconds after the container has started before startup, liveness or readiness probes are initiated.
  # initialDelaySeconds: 1
  # How often (in seconds) to perform the probe.
  # periodSeconds: 10
  # Number of seconds after which the probe times out.
  # timeoutSeconds: 1
  # Minimum consecutive successes for the probe to be considered successful after having failed.
  # successThreshold: 1
  # Minimum consecutive failures for the probe to be considered failed after having succeeded.
  # failureThreshold: 1
  httpGet:
    port: 13133
    path: /

service:
  # Enable the creation of a Service.
  # By default, it's enabled on mode != daemonset.
  # However, to enable it on mode = daemonset, its creation must be explicitly enabled
  enabled: true

  type: ClusterIP
  # type: LoadBalancer
  # loadBalancerIP: 1.2.3.4
  # loadBalancerSourceRanges: []

  # By default, Service of type 'LoadBalancer' will be created setting 'externalTrafficPolicy: Cluster'
  # unless other value is explicitly set.
  # Possible values are Cluster or Local (https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip)
  # externalTrafficPolicy: Cluster

  annotations: {}

  # By default, Service will be created setting 'internalTrafficPolicy: Local' on mode = daemonset
  # unless other value is explicitly set.
  # Setting 'internalTrafficPolicy: Cluster' on a daemonset is not recommended
  # internalTrafficPolicy: Cluster

ingress:
  enabled: false
  # annotations: {}
  # ingressClassName: nginx
  # hosts:
  #   - host: collector.example.com
  #     paths:
  #       - path: /
  #         pathType: Prefix
  #         port: 4318
  # tls:
  #   - secretName: collector-tls
  #     hosts:
  #       - collector.example.com

  # Additional ingresses - only created if ingress.enabled is true
  # Useful for when differently annotated ingress services are required
  # Each additional ingress needs key "name" set to something unique
  additionalIngresses: []
  # - name: cloudwatch
  #   ingressClassName: nginx
  #   annotations: {}
  #   hosts:
  #     - host: collector.example.com
  #       paths:
  #         - path: /
  #           pathType: Prefix
  #           port: 4318
  #   tls:
  #     - secretName: collector-tls
  #       hosts:
  #         - collector.example.com

podMonitor:
  # The pod monitor by default scrapes the metrics port.
  # The metrics port needs to be enabled as well.
  enabled: false
  metricsEndpoints:
    - port: metrics
      # interval: 15s

  # additional labels for the PodMonitor
  extraLabels: {}
  #   release: kube-prometheus-stack

serviceMonitor:
  # The service monitor by default scrapes the metrics port.
  # The metrics port needs to be enabled as well.
  enabled: false
  metricsEndpoints:
    - port: metrics
      interval: 60s

  # additional labels for the ServiceMonitor
  extraLabels: {}
  #  release: kube-prometheus-stack

# PodDisruptionBudget is used only if deployment enabled
podDisruptionBudget:
  enabled: false
#   minAvailable: 2
#   maxUnavailable: 1

# autoscaling is used only if mode is "deployment" or "statefulset"
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  behavior: {}
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

rollout:
  rollingUpdate: {}
  # When 'mode: daemonset', maxSurge cannot be used when hostPort is set for any of the ports
  # maxSurge: 25%
  # maxUnavailable: 0
  strategy: RollingUpdate

prometheusRule:
  enabled: false
  groups: []
  # Create default rules for monitoring the collector
  defaultRules:
    enabled: false

  # additional labels for the PrometheusRule
  extraLabels: {}

statefulset:
  # volumeClaimTemplates for a statefulset
  volumeClaimTemplates: []
  podManagementPolicy: "Parallel"
  # Controls if and how PVCs created by the StatefulSet are deleted. Available in Kubernetes 1.23+.
  persistentVolumeClaimRetentionPolicy:
    enabled: false
    whenDeleted: Retain
    whenScaled: Retain

networkPolicy:
  enabled: false

  # Annotations to add to the NetworkPolicy
  annotations: {}

  # Configure the 'from' clause of the NetworkPolicy.
  # By default this will restrict traffic to ports enabled for the Collector. If
  # you wish to further restrict traffic to other hosts or specific namespaces,
  # see the standard NetworkPolicy 'spec.ingress.from' definition for more info:
  # https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/
  allowIngressFrom: []
  # # Allow traffic from any pod in any namespace, but not external hosts
  # - namespaceSelector: {}
  # # Allow external access from a specific cidr block
  # - ipBlock:
  #     cidr: 192.168.1.64/32
  # # Allow access from pods in specific namespaces
  # - namespaceSelector:
  #     matchExpressions:
  #       - key: kubernetes.io/metadata.name
  #         operator: In
  #         values:
  #           - "cats"
  #           - "dogs"

  # Add additional ingress rules to specific ports
  # Useful to allow external hosts/services to access specific ports
  # An example is allowing an external prometheus server to scrape metrics
  #
  # See the standard NetworkPolicy 'spec.ingress' definition for more info:
  # https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/
  extraIngressRules: []
  # - ports:
  #   - port: metrics
  #     protocol: TCP
  #   from:
  #     - ipBlock:
  #         cidr: 192.168.1.64/32

  # Restrict egress traffic from the OpenTelemetry collector pod
  # See the standard NetworkPolicy 'spec.egress' definition for more info:
  # https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/
  egressRules: []
  #  - to:
  #      - namespaceSelector: {}
  #      - ipBlock:
  #          cidr: 192.168.10.10/24
  #    ports:
  #      - port: 1234
  #        protocol: TCP

# When enabled, the chart will set the GOMEMLIMIT env var to 80% of the configured
# resources.limits.memory and remove the memory ballast extension.
# If no resources.limits.memory are defined enabling does nothing.
# In a future release this setting will be enabled by default.
# See https://github.com/open-telemetry/opentelemetry-helm-charts/issues/891
# for more details.
useGOMEMLIMIT: true
